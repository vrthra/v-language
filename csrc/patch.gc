Index: gc.h
===================================================================
--- gc.h	(revision 235)
+++ gc.h	(working copy)
@@ -1,6 +1,7 @@
 #ifndef GC_H
 #define GC_H
 
+#define HAS_GC 1
 // we need to take into account two kinds of pointers.
 // 1. the member pointers in objects. This can be captured by providing
 // a member wrapper for member objects that gets destroyed when object
@@ -67,19 +68,28 @@
         T* _data;
         
         virtual void attach(T* p, bool a=A) {
+#ifdef HAS_GC
+            if (!p) return;
             Scope* g = Gc::getptr(p);
             if (!g)
                 g = new GcScope<T>(p, a, Gc::phase());
             Gc::addptr(g, this);
+#endif
         }
 
         virtual void detach(T* p) {
+#ifdef HAS_GC
             // we take our reference out.
             Gc::rmptr(this);
+#endif
         }
 
     public:
-        P(T* p):_data(p) {
+        T* v() {
+            return _data;
+        }
+
+        P(T* p=0):_data(p) {
             attach(p);
         }
 
@@ -121,7 +131,7 @@
          * register and continue.
          */
         P<T> &operator = (T *p) {
-            detach(p._data);
+            detach(_data);
             attach(p);
             _data = p;
             return *this;
@@ -129,12 +139,16 @@
 
         /* assignment from pointer object. */
         P<T> &operator = (const P<T> &p) {
-            detach(p._data);
+            detach(_data);
             attach(p._data);
             _data = p._data;
             return *this;
         }
 
+        void detach() {
+            detach(_data);
+        }
+
         ~P() {
             detach(_data);
         }
Index: vstack.h
===================================================================
--- vstack.h	(revision 230)
+++ vstack.h	(working copy)
@@ -16,8 +16,8 @@
         void dequote(Quote* q);
         void dump();
     private:
-        Node* _now;
-        Node* _first;
+        P<Node> _now;
+        P<Node> _first;
         Node* getList();
 };
 
Index: lexiterator.cpp
===================================================================
--- lexiterator.cpp	(revision 230)
+++ lexiterator.cpp	(working copy)
@@ -1,12 +1,16 @@
 #include "lexiterator.h"
 #include "quotestream.h"
+#include "charstream.h"
 #include "lexer.h"
 #include "token.h"
 #include "term.h"
 #include "cmdquote.h"
 #include "vexception.h"
 LexIterator::LexIterator(CharStream* cs)
-    :QuoteIterator(0),_lex(new Lexer(cs)),_current(0) {}
+    :QuoteIterator(0),_lex(0),_current(0) {
+    P<Lexer> l = new Lexer(cs);
+    _lex = l;
+}
 
 bool LexIterator::hasNext() {
     if (!_current)
@@ -16,23 +20,23 @@
     return true;
 }
 Token* LexIterator::next() {
-    Term* t = (Term*)lex_next();
+    P<Token> t = lex_next();
     if (t->type() == TOpen)
         return compound(t);
     return t;
 }
 Token* LexIterator::lex_next() {
     if (_current) {
-        Token* t = _current;
+        P<Token> t = _current;
         _current = 0;
         return t;
     }
     return _lex->next();
 }
 Token* LexIterator::compound(Token* open) {
-    QuoteStream* local = new QuoteStream();
+    P<QuoteStream> local = new QuoteStream();
     while(true) {
-        Token* t = lex_next();
+        P<Token> t = lex_next();
         if (!t)
             throw VSynException("err:lex:close","Compound not closed");
         if (t->type() == TClose)
@@ -43,6 +47,6 @@
         else
             local->add(t);
     }
-    CmdQuote* cq = new CmdQuote(local);
+    P<CmdQuote> cq = new CmdQuote(local);
     return new Term(TQuote, cq);
 }
Index: quotestream.cpp
===================================================================
--- quotestream.cpp	(revision 230)
+++ quotestream.cpp	(working copy)
@@ -1,7 +1,6 @@
 #include "quotestream.h"
 #include "quoteiterator.h"
-QuoteStream::QuoteStream() {
-    _first = new Node(0);
+QuoteStream::QuoteStream():_first(new Node(0)),_stream(0),_size(0) {
     _stream = _first;
     _size = 0;
 }
@@ -16,5 +15,6 @@
 }
 
 TokenIterator* QuoteStream::iterator() {
-    return new QuoteIterator(_first);
+    P<TokenIterator> t = new QuoteIterator(_first);
+    return t;
 }
Index: lexstream.h
===================================================================
--- lexstream.h	(revision 230)
+++ lexstream.h	(working copy)
@@ -7,6 +7,6 @@
         LexStream(CharStream* c);
         virtual TokenIterator* iterator();
     private:
-        CharStream* _stream;
+        P<CharStream> _stream;
 };
 #endif
Index: consolecharstream.cpp
===================================================================
--- consolecharstream.cpp	(revision 231)
+++ consolecharstream.cpp	(working copy)
@@ -25,9 +25,7 @@
 void ConsoleCharStream::lexer(Lexer* l) {
     _lexer = l;
 }
-ConsoleCharStream::ConsoleCharStream() {
-    _index = 0;
-}
+ConsoleCharStream::ConsoleCharStream():_lexer(0),_index(0) {}
 void ConsoleCharStream::read_nobuf() {
     if (_lexer->closed())
         printf("|");
Index: term.h
===================================================================
--- term.h	(revision 230)
+++ term.h	(working copy)
@@ -32,6 +32,7 @@
             char _cval;
             long _lval;
             double _dval;
+        // TODO: GC
             char* _sval;
             Quote* _qval;
             VFrame* _fval;
Index: quoteiterator.h
===================================================================
--- quoteiterator.h	(revision 230)
+++ quoteiterator.h	(working copy)
@@ -8,6 +8,6 @@
         virtual Token* next();
         QuoteIterator(Node* q);
     private:
-        Node* _qs;
+        P<Node> _qs;
 };
 #endif
Index: lexer.cpp
===================================================================
--- lexer.cpp	(revision 230)
+++ lexer.cpp	(working copy)
@@ -7,19 +7,12 @@
 #include "vexception.h"
 #include "v.h"
 
-struct CNode {
-    CNode* link;
-    char c;
-    CNode(char ch):link(0), c(ch) {}
-};
 
-Lexer::Lexer(CharStream* q) {
-    _stream = q;
+Lexer::Lexer(CharStream* q):_stream(q),_queue(new Node(0)),_first(0),_cstack(new CNode(0)) {
     _stream->lexer(this);
     _wi = 0;
     _has = true;
-    _first = _queue = new Node(0);
-    _cstack = new CNode(0);
+    _first = _queue;
 }
 
 void Lexer::lex() {
@@ -76,9 +69,10 @@
     return _cstack->link == 0;
 }
 void Lexer::dump() {
-    Node* i = _first->link;
+    P<Node> i = _first->link;
     while(i) {
-        V::out("%s;", i->data);
+        P<Token> d = i->data;
+        V::out("%s;", d.v());
         i = i->link;
     }
     V::outln("");
@@ -92,7 +86,7 @@
     // if we have return it from there.
     // else run lex and try again.
     if (_first->link != 0) {
-        Token* t = _first->link->data;
+        P<Token> t = _first->link->data;
         _first = _first->link;
         return t;
     } else {
@@ -166,11 +160,12 @@
 void Lexer::copen() {
     char c = _stream->current();
 
-    CNode* t = new CNode(closeCompound(c));
-    t->link = _cstack;
-    _cstack = t;
+    P<CNode> n = new CNode(closeCompound(c));
+    n->link = _cstack;
+    _cstack = n;
 
-    add(new Term(TOpen, c));
+    P<Token> t = new Term(TOpen, c);
+    add(t);
 }
 void Lexer::cclose() {
         if (!_cstack->link)
@@ -180,7 +175,8 @@
 
         if (c != _stream->current())
             throw VSynException("err:internal:invalid_close","Invalid close  - Need close");
-        add(new Term(TClose, _stream->current()));
+        P<Token> t = new Term(TClose, _stream->current());
+        add(t);
 }
 void Lexer::lcomment() {
     while((_stream->read() != '\n') && (!_stream->eof()));
@@ -202,7 +198,8 @@
         _word[_wi++] = c;
     }
     _word[_wi++] = '\0';
-    add(new Term(TString, dup_str(_word)));
+    P<Token> t = new Term(TString, dup_str(_word));
+    add(t);
     _wi = 0;
 }
 void Lexer::space() {
@@ -215,7 +212,8 @@
     }
 }
 void Lexer::character() {
-    add(new Term(TChar, _stream->read()));
+    P<Token> t = new Term(TChar, _stream->read());
+    add(t);
 }
 bool isint(char* v) {
     if (*v == '-') ++v;
@@ -249,11 +247,13 @@
     // does it look like a number?
     _word[_wi++] = '\0';
 
+    P<Token> t = 0;
     if (isint(_word))
-        add(new Term(TInt, atol(_word)));
+        t = new Term(TInt, atol(_word));
     else if (isfloat(_word))
-        add(new Term(TDouble, atof(_word)));
+        t = new Term(TDouble, atof(_word));
     else
-        add(new Term(TSymbol, dup_str(_word)));
+        t = new Term(TSymbol, dup_str(_word));
+    add(t);
     _wi = 0;
 }
Index: vframe.cpp
===================================================================
--- vframe.cpp	(revision 230)
+++ vframe.cpp	(working copy)
@@ -7,14 +7,11 @@
 
 bool singleassign(); // defined in v.cpp
 int VFrame::_idcount = 0;
-VFrame::VFrame() {
-    _parent = 0;
-    _stack = new VStack();
+VFrame::VFrame():_parent(0), _stack(new VStack()) {
     _idcount++;
     _id = _idcount;
 }
-VFrame::VFrame(VFrame* parent) {
-    _parent = parent;
+VFrame::VFrame(VFrame* parent) :_parent(parent), _stack(0) {
     _stack = parent->stack();
     _idcount++;
     _id = _idcount;
@@ -36,15 +33,18 @@
     return 0;
 }
 Quote* VFrame::words() {
-    QuoteStream* nts = new QuoteStream();
+    P<QuoteStream> nts = new QuoteStream();
     for(QMap::iterator i = _dict.begin(); i!= _dict.end(); i++) {
-        nts->add(new Term(TSymbol, i->first));
+        P<Token> t = new Term(TSymbol, i->first);
+        nts->add(t);
     }
     return new CmdQuote(nts); 
 }
 void VFrame::def(char* sym, Quote* q) {
-    if (singleassign() && hasKey(sym))
-        throw VException("err:symbol_already_bound", new Term(TSymbol, sym), sym);
+    if (singleassign() && hasKey(sym)) {
+        P<Token> t =  new Term(TSymbol, sym);
+        throw VException("err:symbol_already_bound",t, sym);
+    }
     _dict[sym] = q;
 }
 
@@ -52,7 +52,8 @@
     return _parent;
 }
 VFrame* VFrame::child() {
-    return new VFrame(this);
+    P<VFrame> f = new VFrame(this);
+    return f;
 }
 VStack* VFrame::stack() {
     return _stack;
Index: cmdquote.cpp
===================================================================
--- cmdquote.cpp	(revision 231)
+++ cmdquote.cpp	(working copy)
@@ -11,8 +11,8 @@
 #include "prologue.h"
 
 void CmdQuote::eval(VFrame* scope) {
-    VStack* stack = scope->stack();
-    TokenIterator* stream = _tokens->iterator();
+    P<VStack> stack = scope->stack();
+    P<TokenIterator> stream = _tokens->iterator();
     while(stream->hasNext()) {
         stack->push(stream->next());
         if (cando(stack))
@@ -22,14 +22,11 @@
 TokenStream* CmdQuote::tokens() {
     return _tokens;
 }
-CmdQuote::CmdQuote(TokenStream* tokens) {
-    _tokens = tokens;
-    _val = 0;
-}
+CmdQuote::CmdQuote(TokenStream* tokens):_tokens(tokens),_val(0) {}
 void CmdQuote::dofunction(VFrame* scope) {
-    VStack* st = scope->stack();
-    Token* sym = st->pop();
-    Quote* q = scope->lookup(sym->svalue());
+    P<VStack> st = scope->stack();
+    P<Token> sym = st->pop();
+    P<Quote> q = scope->lookup(sym->svalue());
     if (!q)
         throw VException("err:undef_symbol", sym, sym->value());
     try {
@@ -52,7 +49,7 @@
     if (!_val) {
         std::ostringstream outs;
         outs << '[';
-        TokenIterator* i = _tokens->iterator();
+        P<TokenIterator> i = _tokens->iterator();
         while(i->hasNext()) {
             outs << i->next()->value();
             if (i->hasNext())
@@ -65,5 +62,8 @@
 }
 
 Quote* CmdQuote::getdef(char* buf) {
-    return new CmdQuote(new LexStream(new BuffCharStream(buf)));
+    P<BuffCharStream> b = new BuffCharStream(buf);
+    P<LexStream> l = new LexStream(b);
+    P<CmdQuote> q = new CmdQuote(l);
+    return q;
 }
Index: common.cpp
===================================================================
--- common.cpp	(revision 230)
+++ common.cpp	(working copy)
@@ -3,7 +3,7 @@
 
 char* dup_str(const char* c) {
     int i = strlen(c);
-    char* out = new char[i + 1];
+    P<char,true> out = new char[i + 1];
     strcpy(out, c);
     return out;
 }
Index: vexception.h
===================================================================
--- vexception.h	(revision 230)
+++ vexception.h	(working copy)
@@ -11,8 +11,8 @@
         virtual void addLine(char* v, ...);
         Token* token();
     private:
-        char* _err;
-        Token* _token;
+        P<char> _err;
+        P<Token> _token;
         char _info[MaxBuf*16];
         int _i;
 };
Index: gc.cpp
===================================================================
--- gc.cpp	(revision 235)
+++ gc.cpp	(working copy)
@@ -69,12 +69,14 @@
 }
 
 void Gc::addptr(Scope* g, void* gcptr) {
-    cout << "\tadd:"<<(int) gcptr << endl;
+    //cout << "\tadd:"<<(int) gcptr << endl;
     // is it already registered?
     __all[g->mem()] = g;
 
     // who owns the scope?
     __current[gcptr] = g;
+    if (__all.size() > 1024*1024)
+        collect();
 }
 
 Scope* Gc::getptr(void* mem) {
@@ -88,6 +90,6 @@
 }
 
 void Gc::rmptr(void* gcptr) {
-    cout << "\tremove:"<<(int) gcptr << endl;
+    //cout << "\tremove:"<<(int) gcptr << endl;
     __current.erase(gcptr);
 }
Index: vstack.cpp
===================================================================
--- vstack.cpp	(revision 230)
+++ vstack.cpp	(working copy)
@@ -4,8 +4,7 @@
 #include "cmdquote.h"
 #include "vexception.h"
 #include "vstack.h"
-VStack::VStack() {
-    _now = new Node(0);
+VStack::VStack():_now(new Node(0)),_first(0) {
     _first = _now;
 }
 
@@ -18,16 +17,18 @@
 }
 
 Token* VStack::push(Token* t) {
-    Node* n = new Node(t);
+    P<Node> n = new Node(t);
     n->link = _now;
     _now = n;
     return _now->data;
 }
 
 Token* VStack::pop() {
-    if (!_now || !_now->data)
-        throw VException("err:stack_empty", new Term(TInt, (long)0), "Empty Stack.");
-    Token* t = _now->data;
+    if (!_now || !_now->data) {
+        P<Token> t = new Term(TInt, (long)0);
+        throw VException("err:stack_empty", t, "Empty Stack.");
+    }
+    P<Token> t = _now->data;
     _now = _now->link;
     return t;
 }
@@ -45,9 +46,9 @@
 }
 
 Node* VStack::getList() {
-    Node* current = _now;
-    Node* result = 0;
-    Node* t = 0;
+    P<Node> current = _now;
+    P<Node> result = 0;
+    P<Node> t = 0;
     while (current && current->data) {
         t = new Node(current->data);
         t->link = result;
@@ -58,18 +59,19 @@
 }
 
 Quote* VStack::quote() {
-    Node* s = getList();
-    QuoteStream* qs = new QuoteStream();
+    P<Node> s = getList();
+    P<QuoteStream> qs = new QuoteStream();
     while(s) {
         qs->add(s->data);
         s = s->link;
     }
-    return new CmdQuote(qs);
+    P<Quote> q = new CmdQuote(qs);
+    return q;
 }
 
 void VStack::dequote(Quote* q) {
-    Node* current = _now;
-    TokenIterator* it = q->tokens()->iterator();
+    P<Node> current = _now;
+    P<TokenIterator> it = q->tokens()->iterator();
 
     _now = new Node(0);
     _first = _now;
@@ -79,7 +81,7 @@
 }
 
 void VStack::dump() {
-    Node* s = getList();
+    P<Node> s = getList();
     printf("(");
     bool first = true;
     while(s) {
Index: buffcharstream.h
===================================================================
--- buffcharstream.h	(revision 230)
+++ buffcharstream.h	(working copy)
@@ -10,7 +10,7 @@
         virtual void lexer(Lexer* l);
         virtual bool eof();
     protected:
-        char* _buf;
+        P<char> _buf;
         int _current;
         int _len;
 };
Index: quote.h
===================================================================
--- quote.h	(revision 230)
+++ quote.h	(working copy)
@@ -1,6 +1,6 @@
 #ifndef QUOTE_H
 #define QUOTE_H
-
+#include "common.h"
 class TokenStream;
 class VFrame;
 struct Quote {
Index: lexstream.cpp
===================================================================
--- lexstream.cpp	(revision 230)
+++ lexstream.cpp	(working copy)
@@ -1,3 +1,5 @@
+#include "lexer.h"
+#include "charstream.h"
 #include "lexstream.h"
 #include "lexiterator.h"
 
@@ -4,5 +6,6 @@
 LexStream::LexStream(CharStream* c) : _stream(c) {
 }
 TokenIterator* LexStream::iterator() {
-    return new LexIterator(_stream);
+    P<LexIterator> i = new LexIterator(_stream);
+    return i;
 }
Index: v.cpp
===================================================================
--- v.cpp	(revision 230)
+++ v.cpp	(working copy)
@@ -62,21 +62,24 @@
 
 void V::main(int argc, char** argv) {
     bool i = argc > 1 ? false : true;
-    VFrame* frame = new VFrame();
-    for(int j=0; j<argc; ++j)
-        frame->stack()->push(new Term(TString, argv[j]));
+    P<VFrame> frame = new VFrame();
+    for(int j=0; j<argc; ++j) {
+        P<Term> t = new Term(TString, argv[j]);
+        frame->stack()->push(t);
+    }
     // setup the world quote
 
     Prologue::init(frame);
     // do we have any args?
-    CharStream* cs = 0;
+    P<CharStream> cs = 0;
     if (argc > 1) {
         cs = new FileCharStream(argv[1]);
     } else {
         banner();
         cs = new ConsoleCharStream();
     }
-    PQuote* program = new PQuote(new LexStream(cs), i);
+    P<LexStream> l = new LexStream(cs);
+    P<PQuote> program = new PQuote(l,i);
     program->eval(frame->child());
 }
 
@@ -84,6 +87,7 @@
 int main(int argc, char** argv) {
     try {
         V::main(argc, argv);
+        Gc::collect();
     } catch (Vx& e) {
         V::outln(e.message());
     }
Index: patch.gc
===================================================================
--- patch.gc	(revision 230)
+++ patch.gc	(working copy)
@@ -1,726 +1,658 @@
-Index: charstream.h
+Index: gc.h
 ===================================================================
---- charstream.h	(revision 223)
-+++ charstream.h	(working copy)
-@@ -2,7 +2,7 @@
- #define CHARSTREAM_H
- #include "common.h"
- struct Lexer;
--struct CharStream {
-+struct CharStream : public gc {
-    virtual char read()=0;
-    virtual char current()=0;
-    virtual char peek()=0;
+--- gc.h	(revision 235)
++++ gc.h	(working copy)
+@@ -1,6 +1,7 @@
+ #ifndef GC_H
+ #define GC_H
+ 
++#define HAS_GC 1
+ // we need to take into account two kinds of pointers.
+ // 1. the member pointers in objects. This can be captured by providing
+ // a member wrapper for member objects that gets destroyed when object
+@@ -67,19 +68,28 @@
+         T* _data;
+         
+         virtual void attach(T* p, bool a=A) {
++#ifdef HAS_GC
++            if (!p) return;
+             Scope* g = Gc::getptr(p);
+             if (!g)
+                 g = new GcScope<T>(p, a, Gc::phase());
+             Gc::addptr(g, this);
++#endif
+         }
+ 
+         virtual void detach(T* p) {
++#ifdef HAS_GC
+             // we take our reference out.
+             Gc::rmptr(this);
++#endif
+         }
+ 
+     public:
+-        P(T* p):_data(p) {
++        T* v() {
++            return _data;
++        }
++
++        P(T* p=0):_data(p) {
+             attach(p);
+         }
+ 
+@@ -121,7 +131,7 @@
+          * register and continue.
+          */
+         P<T> &operator = (T *p) {
+-            detach(p._data);
++            detach(_data);
+             attach(p);
+             _data = p;
+             return *this;
+@@ -129,12 +139,16 @@
+ 
+         /* assignment from pointer object. */
+         P<T> &operator = (const P<T> &p) {
+-            detach(p._data);
++            detach(_data);
+             attach(p._data);
+             _data = p._data;
+             return *this;
+         }
+ 
++        void detach() {
++            detach(_data);
++        }
++
+         ~P() {
+             detach(_data);
+         }
 Index: vstack.h
 ===================================================================
---- vstack.h	(revision 223)
+--- vstack.h	(revision 230)
 +++ vstack.h	(working copy)
-@@ -2,7 +2,7 @@
- #define VSTACK_H
+@@ -16,8 +16,8 @@
+         void dequote(Quote* q);
+         void dump();
+     private:
+-        Node* _now;
+-        Node* _first;
++        P<Node> _now;
++        P<Node> _first;
+         Node* getList();
+ };
+ 
+Index: lexiterator.cpp
+===================================================================
+--- lexiterator.cpp	(revision 230)
++++ lexiterator.cpp	(working copy)
+@@ -1,12 +1,16 @@
+ #include "lexiterator.h"
+ #include "quotestream.h"
++#include "charstream.h"
+ #include "lexer.h"
+ #include "token.h"
  #include "term.h"
- struct Quote;
--class VStack {
-+class VStack : public gc {
-     public:
-         VStack();
-         Node* now();
-Index: tokenstream.h
+ #include "cmdquote.h"
+ #include "vexception.h"
+ LexIterator::LexIterator(CharStream* cs)
+-    :QuoteIterator(0),_lex(new Lexer(cs)),_current(0) {}
++    :QuoteIterator(0),_lex(0),_current(0) {
++    P<Lexer> l = new Lexer(cs);
++    _lex = l;
++}
+ 
+ bool LexIterator::hasNext() {
+     if (!_current)
+@@ -16,23 +20,23 @@
+     return true;
+ }
+ Token* LexIterator::next() {
+-    Term* t = (Term*)lex_next();
++    P<Token> t = lex_next();
+     if (t->type() == TOpen)
+         return compound(t);
+     return t;
+ }
+ Token* LexIterator::lex_next() {
+     if (_current) {
+-        Token* t = _current;
++        P<Token> t = _current;
+         _current = 0;
+         return t;
+     }
+     return _lex->next();
+ }
+ Token* LexIterator::compound(Token* open) {
+-    QuoteStream* local = new QuoteStream();
++    P<QuoteStream> local = new QuoteStream();
+     while(true) {
+-        Token* t = lex_next();
++        P<Token> t = lex_next();
+         if (!t)
+             throw VSynException("err:lex:close","Compound not closed");
+         if (t->type() == TClose)
+@@ -43,6 +47,6 @@
+         else
+             local->add(t);
+     }
+-    CmdQuote* cq = new CmdQuote(local);
++    P<CmdQuote> cq = new CmdQuote(local);
+     return new Term(TQuote, cq);
+ }
+Index: quotestream.cpp
 ===================================================================
---- tokenstream.h	(revision 223)
-+++ tokenstream.h	(working copy)
-@@ -1,7 +1,8 @@
- #ifndef TOKENSTREAM_H
- #define TOKENSTREAM_H
-+#include "common.h"
- class TokenIterator;
--struct TokenStream {
-+struct TokenStream : public gc {
-     virtual TokenIterator* iterator()=0;
+--- quotestream.cpp	(revision 230)
++++ quotestream.cpp	(working copy)
+@@ -1,7 +1,6 @@
+ #include "quotestream.h"
+ #include "quoteiterator.h"
+-QuoteStream::QuoteStream() {
+-    _first = new Node(0);
++QuoteStream::QuoteStream():_first(new Node(0)),_stream(0),_size(0) {
+     _stream = _first;
+     _size = 0;
+ }
+@@ -16,5 +15,6 @@
+ }
+ 
+ TokenIterator* QuoteStream::iterator() {
+-    return new QuoteIterator(_first);
++    P<TokenIterator> t = new QuoteIterator(_first);
++    return t;
+ }
+Index: lexstream.h
+===================================================================
+--- lexstream.h	(revision 230)
++++ lexstream.h	(working copy)
+@@ -7,6 +7,6 @@
+         LexStream(CharStream* c);
+         virtual TokenIterator* iterator();
+     private:
+-        CharStream* _stream;
++        P<CharStream> _stream;
  };
  #endif
-Index: vx.h
+Index: consolecharstream.cpp
 ===================================================================
---- vx.h	(revision 223)
-+++ vx.h	(working copy)
-@@ -1,6 +1,6 @@
- #ifndef VX_H
- #define VX_H
--struct Vx {
-+struct Vx : public gc {
-     virtual char* message() = 0;
-     virtual void addLine(char* v, ...) = 0;
+--- consolecharstream.cpp	(revision 231)
++++ consolecharstream.cpp	(working copy)
+@@ -25,9 +25,7 @@
+ void ConsoleCharStream::lexer(Lexer* l) {
+     _lexer = l;
+ }
+-ConsoleCharStream::ConsoleCharStream() {
+-    _index = 0;
+-}
++ConsoleCharStream::ConsoleCharStream():_lexer(0),_index(0) {}
+ void ConsoleCharStream::read_nobuf() {
+     if (_lexer->closed())
+         printf("|");
+Index: term.h
+===================================================================
+--- term.h	(revision 230)
++++ term.h	(working copy)
+@@ -32,6 +32,7 @@
+             char _cval;
+             long _lval;
+             double _dval;
++        // TODO: GC
+             char* _sval;
+             Quote* _qval;
+             VFrame* _fval;
+Index: quoteiterator.h
+===================================================================
+--- quoteiterator.h	(revision 230)
++++ quoteiterator.h	(working copy)
+@@ -8,6 +8,6 @@
+         virtual Token* next();
+         QuoteIterator(Node* q);
+     private:
+-        Node* _qs;
++        P<Node> _qs;
  };
-Index: tokeniterator.h
+ #endif
+Index: lexer.cpp
 ===================================================================
---- tokeniterator.h	(revision 223)
-+++ tokeniterator.h	(working copy)
-@@ -1,7 +1,8 @@
- #ifndef TOKENITERATOR_H
- #define TOKENITERATOR_H
-+#include "common.h"
- class Token;
--struct TokenIterator {
-+struct TokenIterator : public gc {
-     virtual bool hasNext()=0;
-     virtual Token* next()=0;
+--- lexer.cpp	(revision 230)
++++ lexer.cpp	(working copy)
+@@ -7,19 +7,12 @@
+ #include "vexception.h"
+ #include "v.h"
+ 
+-struct CNode {
+-    CNode* link;
+-    char c;
+-    CNode(char ch):link(0), c(ch) {}
+-};
+ 
+-Lexer::Lexer(CharStream* q) {
+-    _stream = q;
++Lexer::Lexer(CharStream* q):_stream(q),_queue(new Node(0)),_first(0),_cstack(new CNode(0)) {
+     _stream->lexer(this);
+     _wi = 0;
+     _has = true;
+-    _first = _queue = new Node(0);
+-    _cstack = new CNode(0);
++    _first = _queue;
+ }
+ 
+ void Lexer::lex() {
+@@ -76,9 +69,10 @@
+     return _cstack->link == 0;
+ }
+ void Lexer::dump() {
+-    Node* i = _first->link;
++    P<Node> i = _first->link;
+     while(i) {
+-        V::out("%s;", i->data);
++        P<Token> d = i->data;
++        V::out("%s;", d.v());
+         i = i->link;
+     }
+     V::outln("");
+@@ -92,7 +86,7 @@
+     // if we have return it from there.
+     // else run lex and try again.
+     if (_first->link != 0) {
+-        Token* t = _first->link->data;
++        P<Token> t = _first->link->data;
+         _first = _first->link;
+         return t;
+     } else {
+@@ -166,11 +160,12 @@
+ void Lexer::copen() {
+     char c = _stream->current();
+ 
+-    CNode* t = new CNode(closeCompound(c));
+-    t->link = _cstack;
+-    _cstack = t;
++    P<CNode> n = new CNode(closeCompound(c));
++    n->link = _cstack;
++    _cstack = n;
+ 
+-    add(new Term(TOpen, c));
++    P<Token> t = new Term(TOpen, c);
++    add(t);
+ }
+ void Lexer::cclose() {
+         if (!_cstack->link)
+@@ -180,7 +175,8 @@
+ 
+         if (c != _stream->current())
+             throw VSynException("err:internal:invalid_close","Invalid close  - Need close");
+-        add(new Term(TClose, _stream->current()));
++        P<Token> t = new Term(TClose, _stream->current());
++        add(t);
+ }
+ void Lexer::lcomment() {
+     while((_stream->read() != '\n') && (!_stream->eof()));
+@@ -202,7 +198,8 @@
+         _word[_wi++] = c;
+     }
+     _word[_wi++] = '\0';
+-    add(new Term(TString, dup_str(_word)));
++    P<Token> t = new Term(TString, dup_str(_word));
++    add(t);
+     _wi = 0;
+ }
+ void Lexer::space() {
+@@ -215,7 +212,8 @@
+     }
+ }
+ void Lexer::character() {
+-    add(new Term(TChar, _stream->read()));
++    P<Token> t = new Term(TChar, _stream->read());
++    add(t);
+ }
+ bool isint(char* v) {
+     if (*v == '-') ++v;
+@@ -249,11 +247,13 @@
+     // does it look like a number?
+     _word[_wi++] = '\0';
+ 
++    P<Token> t = 0;
+     if (isint(_word))
+-        add(new Term(TInt, atol(_word)));
++        t = new Term(TInt, atol(_word));
+     else if (isfloat(_word))
+-        add(new Term(TDouble, atof(_word)));
++        t = new Term(TDouble, atof(_word));
+     else
+-        add(new Term(TSymbol, dup_str(_word)));
++        t = new Term(TSymbol, dup_str(_word));
++    add(t);
+     _wi = 0;
+ }
+Index: vframe.cpp
+===================================================================
+--- vframe.cpp	(revision 230)
++++ vframe.cpp	(working copy)
+@@ -7,14 +7,11 @@
+ 
+ bool singleassign(); // defined in v.cpp
+ int VFrame::_idcount = 0;
+-VFrame::VFrame() {
+-    _parent = 0;
+-    _stack = new VStack();
++VFrame::VFrame():_parent(0), _stack(new VStack()) {
+     _idcount++;
+     _id = _idcount;
+ }
+-VFrame::VFrame(VFrame* parent) {
+-    _parent = parent;
++VFrame::VFrame(VFrame* parent) :_parent(parent), _stack(0) {
+     _stack = parent->stack();
+     _idcount++;
+     _id = _idcount;
+@@ -36,15 +33,18 @@
+     return 0;
+ }
+ Quote* VFrame::words() {
+-    QuoteStream* nts = new QuoteStream();
++    P<QuoteStream> nts = new QuoteStream();
+     for(QMap::iterator i = _dict.begin(); i!= _dict.end(); i++) {
+-        nts->add(new Term(TSymbol, i->first));
++        P<Token> t = new Term(TSymbol, i->first);
++        nts->add(t);
+     }
+     return new CmdQuote(nts); 
+ }
+ void VFrame::def(char* sym, Quote* q) {
+-    if (singleassign() && hasKey(sym))
+-        throw VException("err:symbol_already_bound", new Term(TSymbol, sym), sym);
++    if (singleassign() && hasKey(sym)) {
++        P<Token> t =  new Term(TSymbol, sym);
++        throw VException("err:symbol_already_bound",t, sym);
++    }
+     _dict[sym] = q;
+ }
+ 
+@@ -52,7 +52,8 @@
+     return _parent;
+ }
+ VFrame* VFrame::child() {
+-    return new VFrame(this);
++    P<VFrame> f = new VFrame(this);
++    return f;
+ }
+ VStack* VFrame::stack() {
+     return _stack;
+Index: cmdquote.cpp
+===================================================================
+--- cmdquote.cpp	(revision 231)
++++ cmdquote.cpp	(working copy)
+@@ -11,8 +11,8 @@
+ #include "prologue.h"
+ 
+ void CmdQuote::eval(VFrame* scope) {
+-    VStack* stack = scope->stack();
+-    TokenIterator* stream = _tokens->iterator();
++    P<VStack> stack = scope->stack();
++    P<TokenIterator> stream = _tokens->iterator();
+     while(stream->hasNext()) {
+         stack->push(stream->next());
+         if (cando(stack))
+@@ -22,14 +22,11 @@
+ TokenStream* CmdQuote::tokens() {
+     return _tokens;
+ }
+-CmdQuote::CmdQuote(TokenStream* tokens) {
+-    _tokens = tokens;
+-    _val = 0;
+-}
++CmdQuote::CmdQuote(TokenStream* tokens):_tokens(tokens),_val(0) {}
+ void CmdQuote::dofunction(VFrame* scope) {
+-    VStack* st = scope->stack();
+-    Token* sym = st->pop();
+-    Quote* q = scope->lookup(sym->svalue());
++    P<VStack> st = scope->stack();
++    P<Token> sym = st->pop();
++    P<Quote> q = scope->lookup(sym->svalue());
+     if (!q)
+         throw VException("err:undef_symbol", sym, sym->value());
+     try {
+@@ -52,7 +49,7 @@
+     if (!_val) {
+         std::ostringstream outs;
+         outs << '[';
+-        TokenIterator* i = _tokens->iterator();
++        P<TokenIterator> i = _tokens->iterator();
+         while(i->hasNext()) {
+             outs << i->next()->value();
+             if (i->hasNext())
+@@ -65,5 +62,8 @@
+ }
+ 
+ Quote* CmdQuote::getdef(char* buf) {
+-    return new CmdQuote(new LexStream(new BuffCharStream(buf)));
++    P<BuffCharStream> b = new BuffCharStream(buf);
++    P<LexStream> l = new LexStream(b);
++    P<CmdQuote> q = new CmdQuote(l);
++    return q;
+ }
+Index: common.cpp
+===================================================================
+--- common.cpp	(revision 230)
++++ common.cpp	(working copy)
+@@ -3,7 +3,7 @@
+ 
+ char* dup_str(const char* c) {
+     int i = strlen(c);
+-    char* out = new char[i + 1];
++    P<char,true> out = new char[i + 1];
+     strcpy(out, c);
+     return out;
+ }
+Index: vexception.h
+===================================================================
+--- vexception.h	(revision 230)
++++ vexception.h	(working copy)
+@@ -11,8 +11,8 @@
+         virtual void addLine(char* v, ...);
+         Token* token();
+     private:
+-        char* _err;
+-        Token* _token;
++        P<char> _err;
++        P<Token> _token;
+         char _info[MaxBuf*16];
+         int _i;
  };
+Index: gc.cpp
+===================================================================
+--- gc.cpp	(revision 235)
++++ gc.cpp	(working copy)
+@@ -69,12 +69,14 @@
+ }
+ 
+ void Gc::addptr(Scope* g, void* gcptr) {
+-    cout << "\tadd:"<<(int) gcptr << endl;
++    //cout << "\tadd:"<<(int) gcptr << endl;
+     // is it already registered?
+     __all[g->mem()] = g;
+ 
+     // who owns the scope?
+     __current[gcptr] = g;
++    if (__all.size() > 1024*1024)
++        collect();
+ }
+ 
+ Scope* Gc::getptr(void* mem) {
+@@ -88,6 +90,6 @@
+ }
+ 
+ void Gc::rmptr(void* gcptr) {
+-    cout << "\tremove:"<<(int) gcptr << endl;
++    //cout << "\tremove:"<<(int) gcptr << endl;
+     __current.erase(gcptr);
+ }
+Index: vstack.cpp
+===================================================================
+--- vstack.cpp	(revision 230)
++++ vstack.cpp	(working copy)
+@@ -4,8 +4,7 @@
+ #include "cmdquote.h"
+ #include "vexception.h"
+ #include "vstack.h"
+-VStack::VStack() {
+-    _now = new Node(0);
++VStack::VStack():_now(new Node(0)),_first(0) {
+     _first = _now;
+ }
+ 
+@@ -18,16 +17,18 @@
+ }
+ 
+ Token* VStack::push(Token* t) {
+-    Node* n = new Node(t);
++    P<Node> n = new Node(t);
+     n->link = _now;
+     _now = n;
+     return _now->data;
+ }
+ 
+ Token* VStack::pop() {
+-    if (!_now || !_now->data)
+-        throw VException("err:stack_empty", new Term(TInt, (long)0), "Empty Stack.");
+-    Token* t = _now->data;
++    if (!_now || !_now->data) {
++        P<Token> t = new Term(TInt, (long)0);
++        throw VException("err:stack_empty", t, "Empty Stack.");
++    }
++    P<Token> t = _now->data;
+     _now = _now->link;
+     return t;
+ }
+@@ -45,9 +46,9 @@
+ }
+ 
+ Node* VStack::getList() {
+-    Node* current = _now;
+-    Node* result = 0;
+-    Node* t = 0;
++    P<Node> current = _now;
++    P<Node> result = 0;
++    P<Node> t = 0;
+     while (current && current->data) {
+         t = new Node(current->data);
+         t->link = result;
+@@ -58,18 +59,19 @@
+ }
+ 
+ Quote* VStack::quote() {
+-    Node* s = getList();
+-    QuoteStream* qs = new QuoteStream();
++    P<Node> s = getList();
++    P<QuoteStream> qs = new QuoteStream();
+     while(s) {
+         qs->add(s->data);
+         s = s->link;
+     }
+-    return new CmdQuote(qs);
++    P<Quote> q = new CmdQuote(qs);
++    return q;
+ }
+ 
+ void VStack::dequote(Quote* q) {
+-    Node* current = _now;
+-    TokenIterator* it = q->tokens()->iterator();
++    P<Node> current = _now;
++    P<TokenIterator> it = q->tokens()->iterator();
+ 
+     _now = new Node(0);
+     _first = _now;
+@@ -79,7 +81,7 @@
+ }
+ 
+ void VStack::dump() {
+-    Node* s = getList();
++    P<Node> s = getList();
+     printf("(");
+     bool first = true;
+     while(s) {
+Index: buffcharstream.h
+===================================================================
+--- buffcharstream.h	(revision 230)
++++ buffcharstream.h	(working copy)
+@@ -10,7 +10,7 @@
+         virtual void lexer(Lexer* l);
+         virtual bool eof();
+     protected:
+-        char* _buf;
++        P<char> _buf;
+         int _current;
+         int _len;
+ };
 Index: quote.h
 ===================================================================
---- quote.h	(revision 223)
+--- quote.h	(revision 230)
 +++ quote.h	(working copy)
-@@ -1,9 +1,9 @@
+@@ -1,6 +1,6 @@
  #ifndef QUOTE_H
  #define QUOTE_H
 -
 +#include "common.h"
  class TokenStream;
  class VFrame;
--struct Quote {
-+struct Quote : public gc {
-     virtual void eval(VFrame* scope) = 0;
-     virtual TokenStream* tokens() = 0;
-     virtual char* to_s() = 0;
-Index: patch.gc
+ struct Quote {
+Index: lexstream.cpp
 ===================================================================
---- patch.gc	(revision 223)
-+++ patch.gc	(working copy)
-@@ -1,6 +1,6 @@
- Index: charstream.h
- ===================================================================
----- charstream.h	(revision 218)
-+--- charstream.h	(revision 223)
- +++ charstream.h	(working copy)
- @@ -2,7 +2,7 @@
-  #define CHARSTREAM_H
-@@ -13,19 +13,11 @@
-     virtual char peek()=0;
- Index: vstack.h
- ===================================================================
----- vstack.h	(revision 218)
-+--- vstack.h	(revision 223)
- +++ vstack.h	(working copy)
--@@ -2,15 +2,8 @@
-+@@ -2,7 +2,7 @@
-  #define VSTACK_H
-  #include "term.h"
-- 
---struct Node {
---    Token* data;
---    Node* link;
---    Node(Token* e) {
---        data = e;
---    }
---};
-  struct Quote;
- -class VStack {
- +class VStack : public gc {
-@@ -34,7 +26,7 @@
-          Node* now();
- Index: tokenstream.h
- ===================================================================
----- tokenstream.h	(revision 218)
-+--- tokenstream.h	(revision 223)
- +++ tokenstream.h	(working copy)
- @@ -1,7 +1,8 @@
-  #ifndef TOKENSTREAM_H
-@@ -48,7 +40,7 @@
-  #endif
- Index: vx.h
- ===================================================================
----- vx.h	(revision 218)
-+--- vx.h	(revision 223)
- +++ vx.h	(working copy)
- @@ -1,6 +1,6 @@
-  #ifndef VX_H
-@@ -58,102 +50,9 @@
-      virtual char* message() = 0;
-      virtual void addLine(char* v, ...) = 0;
-  };
--Index: lexiterator.cpp
--===================================================================
----- lexiterator.cpp	(revision 218)
--+++ lexiterator.cpp	(working copy)
--@@ -5,8 +5,8 @@
-- #include "term.h"
-- #include "cmdquote.h"
-- #include "vexception.h"
---LexIterator::LexIterator(QuoteStream* qs, CharStream* cs)
---    :QuoteIterator(qs),_lex(new Lexer(cs)),_current(0) {}
--+LexIterator::LexIterator(CharStream* cs)
--+    :QuoteIterator(0),_lex(new Lexer(cs)),_current(0) {}
-- 
-- bool LexIterator::hasNext() {
--     if (!_current)
--@@ -19,6 +19,8 @@
--     Term* t = (Term*)lex_next();
--     if (t->type() == TOpen)
--         return compound(t);
--+    if (t->type() == TClose)
--+        throw VSynException("err:lex:close","Unexpected Quote close");
--     return t;
-- }
-- Token* LexIterator::lex_next() {
--@@ -35,9 +37,11 @@
--         Token* t = lex_next();
--         if (!t)
--             throw VSynException("err:lex:close","Compound not closed");
---        if (t->type() == TClose)
--+        if (t->type() == TClose) {
--             if (t->cvalue() == Lexer::closeCompound(open->cvalue()))
--                 break;
--+            throw VSynException("err:lex:close","invalid compound close");
--+        }
--         if (t->type() == TOpen)
--             local->add(compound(t));
--         else
--Index: quotestream.cpp
--===================================================================
----- quotestream.cpp	(revision 218)
--+++ quotestream.cpp	(working copy)
--@@ -1,19 +1,23 @@
--+#include "common.h"
--+#include "token.h"
-- #include "quotestream.h"
-- #include "quoteiterator.h"
--+
-- QuoteStream::QuoteStream() {
--+    _stream = new Node(0);
--+    _size = 0;
--+    _first = _stream;
-- }
-- void QuoteStream::add(Token* t) {
---    _stream.push_back(t);
--+    _stream->link = new Node(t);
--+    _stream = _stream->link;
--+    ++_size;
-- }
-- 
-- int QuoteStream::size() {
---    return _stream.size();
--+    return _size;
-- }
-- 
---Token* QuoteStream::get(int i) {
---    return _stream[i];
---}
---
-- TokenIterator* QuoteStream::iterator() {
---    return (TokenIterator*)new QuoteIterator(this);
--+    return new QuoteIterator(_first);
-- }
--Index: quoteiterator.h
--===================================================================
----- quoteiterator.h	(revision 218)
--+++ quoteiterator.h	(working copy)
--@@ -2,13 +2,13 @@
-- #define QUOTEITERATOR_H
-- #include "tokeniterator.h"
-- class QuoteStream;
--+class Node;
-- class QuoteIterator : public TokenIterator {
--     public:
--         virtual bool hasNext();
--         virtual Token* next();
---        QuoteIterator(QuoteStream* q);
--+        QuoteIterator(Node* q);
--     private:
---        QuoteStream* _qs;
---        int _index;
--+        Node* _qs;
-- };
-- #endif
- Index: tokeniterator.h
- ===================================================================
----- tokeniterator.h	(revision 218)
-+--- tokeniterator.h	(revision 223)
- +++ tokeniterator.h	(working copy)
- @@ -1,7 +1,8 @@
-  #ifndef TOKENITERATOR_H
-@@ -167,7 +66,7 @@
-  };
- Index: quote.h
- ===================================================================
----- quote.h	(revision 218)
-+--- quote.h	(revision 223)
- +++ quote.h	(working copy)
- @@ -1,9 +1,9 @@
-  #ifndef QUOTE_H
-@@ -181,407 +80,3 @@
-      virtual void eval(VFrame* scope) = 0;
-      virtual TokenStream* tokens() = 0;
-      virtual char* to_s() = 0;
--Index: lexstream.cpp
--===================================================================
----- lexstream.cpp	(revision 218)
--+++ lexstream.cpp	(working copy)
--@@ -4,5 +4,5 @@
-- LexStream::LexStream(CharStream* c) : _stream(c) {
-- }
-- TokenIterator* LexStream::iterator() {
---    return new LexIterator(this,_stream);
--+    return new LexIterator(_stream);
-- }
--Index: patch.gc
--===================================================================
----- patch.gc	(revision 218)
--+++ patch.gc	(working copy)
--@@ -1,24 +1,194 @@
---Index: buffcharstream.h
--+Index: charstream.h
-- ===================================================================
------ buffcharstream.h	(revision 212)
---+++ buffcharstream.h	(working copy)
---@@ -4,6 +4,7 @@
--- class BuffCharStream : public CharStream {
--+--- charstream.h	(revision 218)
--++++ charstream.h	(working copy)
--+@@ -2,7 +2,7 @@
--+ #define CHARSTREAM_H
--+ #include "common.h"
--+ struct Lexer;
--+-struct CharStream {
--++struct CharStream : public gc {
--+    virtual char read()=0;
--+    virtual char current()=0;
--+    virtual char peek()=0;
--+Index: vstack.h
--+===================================================================
--+--- vstack.h	(revision 218)
--++++ vstack.h	(working copy)
--+@@ -2,15 +2,8 @@
--+ #define VSTACK_H
--+ #include "term.h"
--+ 
--+-struct Node {
--+-    Token* data;
--+-    Node* link;
--+-    Node(Token* e) {
--+-        data = e;
--+-    }
--+-};
--+ struct Quote;
--+-class VStack {
--++class VStack : public gc {
--      public:
---         BuffCharStream(char* buff);
---+        ~BuffCharStream();
---         virtual char read();
---         virtual char peek();
---         virtual char current();
---Index: buffcharstream.cpp
--+         VStack();
--+         Node* now();
--+Index: tokenstream.h
-- ===================================================================
------ buffcharstream.cpp	(revision 212)
---+++ buffcharstream.cpp	(working copy)
---@@ -24,3 +24,7 @@
---         std::strcpy(_buf, buff);
---     }
--+--- tokenstream.h	(revision 218)
--++++ tokenstream.h	(working copy)
--+@@ -1,7 +1,8 @@
--+ #ifndef TOKENSTREAM_H
--+ #define TOKENSTREAM_H
--++#include "common.h"
--+ class TokenIterator;
--+-struct TokenStream {
--++struct TokenStream : public gc {
--+     virtual TokenIterator* iterator()=0;
--+ };
--+ #endif
--+Index: vx.h
--+===================================================================
--+--- vx.h	(revision 218)
--++++ vx.h	(working copy)
--+@@ -1,6 +1,6 @@
--+ #ifndef VX_H
--+ #define VX_H
--+-struct Vx {
--++struct Vx : public gc {
--+     virtual char* message() = 0;
--+     virtual void addLine(char* v, ...) = 0;
--+ };
--+Index: lexiterator.cpp
--+===================================================================
--+--- lexiterator.cpp	(revision 218)
--++++ lexiterator.cpp	(working copy)
--+@@ -5,8 +5,8 @@
--+ #include "term.h"
--+ #include "cmdquote.h"
--+ #include "vexception.h"
--+-LexIterator::LexIterator(QuoteStream* qs, CharStream* cs)
--+-    :QuoteIterator(qs),_lex(new Lexer(cs)),_current(0) {}
--++LexIterator::LexIterator(CharStream* cs)
--++    :QuoteIterator(0),_lex(new Lexer(cs)),_current(0) {}
--+ 
--+ bool LexIterator::hasNext() {
--+     if (!_current)
--+@@ -19,6 +19,8 @@
--+     Term* t = (Term*)lex_next();
--+     if (t->type() == TOpen)
--+         return compound(t);
--++    if (t->type() == TClose)
--++        throw VSynException("err:lex:close","Unexpected Quote close");
--+     return t;
--  }
---+BuffCharStream::~BuffCharStream() {
---+    if (_buf)
---+        delete[] _buf;
---+}
--+ Token* LexIterator::lex_next() {
--+@@ -35,9 +37,11 @@
--+         Token* t = lex_next();
--+         if (!t)
--+             throw VSynException("err:lex:close","Compound not closed");
--+-        if (t->type() == TClose)
--++        if (t->type() == TClose) {
--+             if (t->cvalue() == Lexer::closeCompound(open->cvalue()))
--+                 break;
--++            throw VSynException("err:lex:close","invalid compound close");
--++        }
--+         if (t->type() == TOpen)
--+             local->add(compound(t));
--+         else
--+Index: quotestream.cpp
--+===================================================================
--+--- quotestream.cpp	(revision 218)
--++++ quotestream.cpp	(working copy)
--+@@ -1,19 +1,23 @@
--++#include "common.h"
--++#include "token.h"
--+ #include "quotestream.h"
--+ #include "quoteiterator.h"
--++
--+ QuoteStream::QuoteStream() {
--++    _stream = new Node(0);
--++    _size = 0;
--++    _first = _stream;
--+ }
--+ void QuoteStream::add(Token* t) {
--+-    _stream.push_back(t);
--++    _stream->link = new Node(t);
--++    _stream = _stream->link;
--++    ++_size;
--+ }
--+ 
--+ int QuoteStream::size() {
--+-    return _stream.size();
--++    return _size;
--+ }
--+ 
--+-Token* QuoteStream::get(int i) {
--+-    return _stream[i];
--+-}
--+-
--+ TokenIterator* QuoteStream::iterator() {
--+-    return (TokenIterator*)new QuoteIterator(this);
--++    return new QuoteIterator(_first);
--+ }
--+Index: quoteiterator.h
--+===================================================================
--+--- quoteiterator.h	(revision 218)
--++++ quoteiterator.h	(working copy)
--+@@ -2,13 +2,13 @@
--+ #define QUOTEITERATOR_H
--+ #include "tokeniterator.h"
--+ class QuoteStream;
--++class Node;
--+ class QuoteIterator : public TokenIterator {
--+     public:
--+         virtual bool hasNext();
--+         virtual Token* next();
--+-        QuoteIterator(QuoteStream* q);
--++        QuoteIterator(Node* q);
--+     private:
--+-        QuoteStream* _qs;
--+-        int _index;
--++        Node* _qs;
--+ };
--+ #endif
--+Index: tokeniterator.h
--+===================================================================
--+--- tokeniterator.h	(revision 218)
--++++ tokeniterator.h	(working copy)
--+@@ -1,7 +1,8 @@
--+ #ifndef TOKENITERATOR_H
--+ #define TOKENITERATOR_H
--++#include "common.h"
--+ class Token;
--+-struct TokenIterator {
--++struct TokenIterator : public gc {
--+     virtual bool hasNext()=0;
--+     virtual Token* next()=0;
--+ };
--+Index: quote.h
--+===================================================================
--+--- quote.h	(revision 218)
--++++ quote.h	(working copy)
--+@@ -1,9 +1,9 @@
--+ #ifndef QUOTE_H
--+ #define QUOTE_H
--+-
--++#include "common.h"
--+ class TokenStream;
--+ class VFrame;
--+-struct Quote {
--++struct Quote : public gc {
--+     virtual void eval(VFrame* scope) = 0;
--+     virtual TokenStream* tokens() = 0;
--+     virtual char* to_s() = 0;
--+Index: lexstream.cpp
--+===================================================================
--+--- lexstream.cpp	(revision 218)
--++++ lexstream.cpp	(working copy)
--+@@ -4,5 +4,5 @@
--+ LexStream::LexStream(CharStream* c) : _stream(c) {
--+ }
--+ TokenIterator* LexStream::iterator() {
--+-    return new LexIterator(this,_stream);
--++    return new LexIterator(_stream);
--+ }
--Index: term.cpp
--===================================================================
----- term.cpp	(revision 218)
--+++ term.cpp	(working copy)
--@@ -67,6 +67,10 @@
--             return qvalue()->to_s();
--         case TFrame:
--             return fvalue()->to_s();
--+        case TOpen:
--+            return "<?? open>";
--+        case TClose:
--+            return "<?? close>";
--         default:
--             return "<default>";
--     }
--@@ -83,6 +87,8 @@
--         case TBool: return "<bool>";
--         case TQuote: return "<quote>";
--         case TFrame: return "<frame>";
--+        case TOpen : return "<? open>";
--+        case TClose : return "<? close>";
--         default: return "<?>";
--     }
-- }
--Index: quoteiterator.cpp
--===================================================================
----- quoteiterator.cpp	(revision 218)
--+++ quoteiterator.cpp	(working copy)
--@@ -1,14 +1,14 @@
--+#include "token.h"
-- #include "quoteiterator.h"
-- #include "quotestream.h"
-- 
---QuoteIterator::QuoteIterator(QuoteStream* q):_qs(q),_index(0) {}
--+QuoteIterator::QuoteIterator(Node* q):_qs(q) {}
-- 
-- bool QuoteIterator::hasNext() {
---    if (_qs->size() > _index)
---        return true;
---    return false;
--+    return _qs->link != 0;
-- }
-- 
-- Token* QuoteIterator::next() {
---    return _qs->get(_index++);
--+    _qs = _qs->link;
--+    return _qs->data;
-- }
--Index: lexiterator.h
--===================================================================
----- lexiterator.h	(revision 218)
--+++ lexiterator.h	(working copy)
--@@ -7,7 +7,7 @@
-- class CharStream;
-- class LexIterator : public QuoteIterator {
--     public:
---        LexIterator(QuoteStream* qs, CharStream* cs);
--+        LexIterator(CharStream* cs);
--         virtual bool hasNext();
--         virtual Token* next();
--     private:
--Index: quotestream.h
--===================================================================
----- quotestream.h	(revision 218)
--+++ quotestream.h	(working copy)
--@@ -3,15 +3,18 @@
-- #include <vector>
-- #include "tokenstream.h"
-- class Token;
--+class Node;
-- class QuoteIterator;
--+
-- class QuoteStream : public TokenStream {
--     public:
--         QuoteStream();
--         virtual void add(Token* t);
--         virtual int size();
---        virtual Token* get(int i);
--         virtual TokenIterator* iterator();
---    protected:
---        std::vector<Token*> _stream;
--+    private:
--+        Node* _stream;
--+        int _size;
--+        Node* _first;
-- };
-- #endif
--Index: consolecharstream.h
--===================================================================
----- consolecharstream.h	(revision 218)
--+++ consolecharstream.h	(working copy)
--@@ -1,6 +1,5 @@
-- #ifndef CONSOLECHARSTREAM_H
-- #define CONSOLECHARSTREAM_H
---#include <vector>
-- #include "charstream.h"
-- struct Lexer;
-- class ConsoleCharStream : public CharStream {
--Index: lexer.h
--===================================================================
----- lexer.h	(revision 218)
--+++ lexer.h	(working copy)
--@@ -3,9 +3,10 @@
-- #include <vector>
-- #include <stack>
-- #include <list>
--+#include "common.h"
-- class CharStream;
-- class Term;
---class Lexer {
--+class Lexer : public gc {
--     public:
--         Lexer(CharStream* q);
--         void lex();
--Index: vframe.h
--===================================================================
----- vframe.h	(revision 218)
--+++ vframe.h	(working copy)
--@@ -5,7 +5,7 @@
-- class Quote;
-- class VStack;
-- typedef std::map<char*, Quote*, cmp_str> QMap;
---class VFrame {
--+class VFrame : public gc {
--     public:
--         int id();
-- 
--Index: token.h
--===================================================================
----- token.h	(revision 218)
--+++ token.h	(working copy)
--@@ -1,11 +1,12 @@
-- #ifndef TOKEN_H
-- #define TOKEN_H
--+#include "common.h"
-- #include "type.h"
-- #include "num.h"
-- class Quote;
-- class VFrame;
-- class Num;
---struct Token {
--+struct Token : public gc {
--     virtual char* value()=0;
--     virtual Type type()=0;
--     virtual bool bvalue()=0;
--@@ -17,4 +18,13 @@
--     virtual VFrame* fvalue()=0;
--     virtual Num numvalue()=0;
-- };
--+
--+struct Node : public gc {
--+    Token* data;
--+    Node* link;
--+    Node(Token* e) {
--+        data = e;
--+    }
--+};
--+
-- #endif
--Index: common.h
--===================================================================
----- common.h	(revision 218)
--+++ common.h	(working copy)
--@@ -9,5 +9,9 @@
-- 
-- static const double Precision = 0.0000000000000001;
-- static const int MaxBuf = 1024;
---
--+#ifdef HAS_GC
--+#include <gc/gc_cpp.h>
--+#else
--+class gc {};
-- #endif
--+#endif
-Index: lexer.h
-===================================================================
---- lexer.h	(revision 223)
-+++ lexer.h	(working copy)
-@@ -3,9 +3,10 @@
- #include <vector>
- #include <stack>
- #include <list>
-+#include "common.h"
- class CharStream;
- class Term;
--class Lexer {
-+class Lexer : public gc {
-     public:
-         Lexer(CharStream* q);
-         void lex();
-Index: vframe.h
-===================================================================
---- vframe.h	(revision 223)
-+++ vframe.h	(working copy)
-@@ -5,7 +5,7 @@
- class Quote;
- class VStack;
- typedef std::map<char*, Quote*, cmp_str> QMap;
--class VFrame {
-+class VFrame : public gc {
-     public:
-         int id();
+--- lexstream.cpp	(revision 230)
++++ lexstream.cpp	(working copy)
+@@ -1,3 +1,5 @@
++#include "lexer.h"
++#include "charstream.h"
+ #include "lexstream.h"
+ #include "lexiterator.h"
  
-Index: token.h
+@@ -4,5 +6,6 @@
+ LexStream::LexStream(CharStream* c) : _stream(c) {
+ }
+ TokenIterator* LexStream::iterator() {
+-    return new LexIterator(_stream);
++    P<LexIterator> i = new LexIterator(_stream);
++    return i;
+ }
+Index: v.cpp
 ===================================================================
---- token.h	(revision 223)
-+++ token.h	(working copy)
-@@ -1,11 +1,12 @@
- #ifndef TOKEN_H
- #define TOKEN_H
-+#include "common.h"
- #include "type.h"
- #include "num.h"
- class Quote;
- class VFrame;
- class Num;
--struct Token {
-+struct Token : public gc {
-     virtual char* value()=0;
-     virtual Type type()=0;
-     virtual bool bvalue()=0;
-@@ -18,7 +19,7 @@
-     virtual Num numvalue()=0;
- };
+--- v.cpp	(revision 230)
++++ v.cpp	(working copy)
+@@ -62,21 +62,24 @@
  
--struct Node {
-+struct Node : public gc {
-     Token* data;
-     Node* link;
-     Node(Token* e) {
-Index: common.h
-===================================================================
---- common.h	(revision 223)
-+++ common.h	(working copy)
-@@ -9,5 +9,9 @@
+ void V::main(int argc, char** argv) {
+     bool i = argc > 1 ? false : true;
+-    VFrame* frame = new VFrame();
+-    for(int j=0; j<argc; ++j)
+-        frame->stack()->push(new Term(TString, argv[j]));
++    P<VFrame> frame = new VFrame();
++    for(int j=0; j<argc; ++j) {
++        P<Term> t = new Term(TString, argv[j]);
++        frame->stack()->push(t);
++    }
+     // setup the world quote
  
- static const double Precision = 0.0000000000000001;
- static const int MaxBuf = 1024;
--
-+#ifdef HAS_GC
-+#include <gc/gc_cpp.h>
-+#else
-+class gc {};
- #endif
-+#endif
+     Prologue::init(frame);
+     // do we have any args?
+-    CharStream* cs = 0;
++    P<CharStream> cs = 0;
+     if (argc > 1) {
+         cs = new FileCharStream(argv[1]);
+     } else {
+         banner();
+         cs = new ConsoleCharStream();
+     }
+-    PQuote* program = new PQuote(new LexStream(cs), i);
++    P<LexStream> l = new LexStream(cs);
++    P<PQuote> program = new PQuote(l,i);
+     program->eval(frame->child());
+ }
+ 
+@@ -84,6 +87,7 @@
+ int main(int argc, char** argv) {
+     try {
+         V::main(argc, argv);
++        Gc::collect();
+     } catch (Vx& e) {
+         V::outln(e.message());
+     }
Index: lexiterator.h
===================================================================
--- lexiterator.h	(revision 230)
+++ lexiterator.h	(working copy)
@@ -13,7 +13,7 @@
     private:
         Token* lex_next();
         Token* compound(Token* open);
-        Lexer* _lex;
-        Token* _current;
+        P<Lexer> _lex;
+        P<Token> _current;
 };
 #endif
Index: quotestream.h
===================================================================
--- quotestream.h	(revision 230)
+++ quotestream.h	(working copy)
@@ -11,8 +11,8 @@
         virtual int size();
         virtual TokenIterator* iterator();
     protected:
-        Node* _stream;
-        Node* _first;
+        P<Node> _stream;
+        P<Node> _first;
         long _size;
 };
 #endif
Index: consolecharstream.h
===================================================================
--- consolecharstream.h	(revision 231)
+++ consolecharstream.h	(working copy)
@@ -13,7 +13,7 @@
     private:
         char _buf[MaxBuf];
         int _index;
-        Lexer* _lexer;
+        P<Lexer> _lexer;
         char _current;
         void read_nobuf();
         virtual int index();
Index: lexer.h
===================================================================
--- lexer.h	(revision 230)
+++ lexer.h	(working copy)
@@ -3,7 +3,13 @@
 #include "common.h"
 #include "token.h"
 class CharStream;
-class CNode;
+
+struct CNode {
+    P<CNode> link;
+    char c;
+    CNode(char ch):link(0), c(ch) {}
+};
+
 class Lexer {
     public:
         Lexer(CharStream* q);
@@ -32,12 +38,12 @@
         char _word[MaxBuf];
         int _wi;
 
-        CNode* _cstack;
+        P<CNode> _cstack;
 
-        Node* _queue;
-        Node* _first;
+        P<Node> _queue;
+        P<Node> _first;
 
-        CharStream* _stream;
+        P<CharStream> _stream;
         bool _has;
 };
 #endif
Index: vexception.cpp
===================================================================
--- vexception.cpp	(revision 230)
+++ vexception.cpp	(working copy)
@@ -5,8 +5,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-VException::VException(char* err, Token* t, char* msgfmt, ...):_token(t){
-    _err = err;
+VException::VException(char* err, Token* t, char* msgfmt, ...):_token(t),_err(err) {
     _i = 0;
     va_list argp;
     va_start(argp, msgfmt);
Index: vframe.h
===================================================================
--- vframe.h	(revision 231)
+++ vframe.h	(working copy)
@@ -25,7 +25,7 @@
         int _id;
         bool hasKey(char* key);
         QMap _dict;
-        VStack* _stack;
-        VFrame* _parent;
+        P<VStack> _stack;
+        P<VFrame> _parent;
 };
 #endif
Index: token.h
===================================================================
--- token.h	(revision 231)
+++ token.h	(working copy)
@@ -1,5 +1,6 @@
 #ifndef TOKEN_H
 #define TOKEN_H
+#include "common.h"
 #include "type.h"
 #include "num.h"
 class Quote;
@@ -19,12 +20,9 @@
 };
 
 struct Node {
-    Token* data;
-    Node* link;
-    Node(Token* e) {
-        data = e;
-        link = 0;
-    }
+    P<Token> data;
+    P<Node> link;
+    Node(Token* e):data(e), link(0){}
 };
 
 #endif
Index: cmdquote.h
===================================================================
--- cmdquote.h	(revision 231)
+++ cmdquote.h	(working copy)
@@ -14,6 +14,6 @@
     private:
         bool cando(VStack* stack);
         TokenStream* _tokens;
-        char* _val;
+        P<char> _val;
 };
 #endif
Index: prologue.cpp
===================================================================
--- prologue.cpp	(revision 230)
+++ prologue.cpp	(working copy)
@@ -17,23 +17,23 @@
 #include "std.h"
 ;*/
 
-typedef std::map<char*, Token*, cmp_str> SymbolMap;
+typedef std::map<P<char>, P<Token>, cmp_str> SymbolMap;
 typedef std::pair<char*, Quote*> SymPair;
 
 SymPair splitdef(Quote* qval) {
-    TokenIterator* it = qval->tokens()->iterator();
-    Token* symbol = it->next();
+    P<TokenIterator> it = qval->tokens()->iterator();
+    P<Token> symbol = it->next();
 
-    QuoteStream* nts = new QuoteStream();
+    P<QuoteStream> nts = new QuoteStream();
     while(it->hasNext())
         nts->add(it->next());
-
-    return std::make_pair<char*, Quote*>(symbol->svalue(), new CmdQuote(nts));
+    P<Quote> q = new CmdQuote(nts);
+    return std::make_pair<char*, Quote*>(symbol->svalue(),q);
 }
 
 char* special(char* name) {
     int len = strlen(name);
-    char* buf = new char[len + 2];
+    P<char,true> buf = new char[len + 2];
     buf[0] = '$';
     std::strcpy(buf+1, name);
     return buf;
@@ -41,10 +41,10 @@
 
 void evaltmpl(TokenStream* tmpl, TokenStream* elem, SymbolMap& symbols) {
     //Take each point in tmpl, and proess elements accordingly.
-    TokenIterator* tstream = tmpl->iterator();
-    TokenIterator* estream = elem->iterator();
+    P<TokenIterator> tstream = tmpl->iterator();
+    P<TokenIterator> estream = elem->iterator();
     while(tstream->hasNext()) {
-        Token* t = tstream->next();
+        P<Token> t = tstream->next();
         switch (t->type()) {
             case TSymbol:
                 try {
@@ -57,13 +57,13 @@
                         estream->next();
                         break;
                     } else if (value[0] == '*') {
-                        QuoteStream* nlist = new QuoteStream();
+                        P<QuoteStream> nlist = new QuoteStream();
                         // * is all. but before we slurp, check the next element
                         // in the template. If there is not any, then slurp. If there
                         // is one, then slurp until last but one, and leave it.
                         if (tstream->hasNext()) {
-                            Token* tmplterm = tstream->next();
-                            Token* lastelem = 0;
+                            P<Token> tmplterm = tstream->next();
+                            P<Token> lastelem = 0;
 
                             // slurp till last but one.
                             while(estream->hasNext()) {
@@ -93,7 +93,8 @@
                                 nlist->add(estream->next());
                         }
                         if (strlen(value) > 1) { // do we have a named list?
-                            symbols[value] = new Term(TQuote, new CmdQuote(nlist));
+                            P<Quote> q = new CmdQuote(nlist);
+                            symbols[value] = new Term(TQuote, q);
                         }
                     } else {
                         Token* e = estream->next();
@@ -137,32 +138,38 @@
 }
 
 TokenStream* evalres(TokenStream* res, SymbolMap& symbols) {
-        QuoteStream* r = new QuoteStream();
-        TokenIterator* rstream = res->iterator();
+        P<QuoteStream> r = new QuoteStream();
+        P<TokenIterator> rstream = res->iterator();
         while(rstream->hasNext()) {
-            Token* t = rstream->next();
+            P<Token> t = rstream->next();
             switch(t->type()) {
 
                 case TQuote:
-                    QuoteStream* nq = (QuoteStream*)evalres(t->qvalue()->tokens(), symbols);
-                    r->add(new Term(TQuote, new CmdQuote(nq)));
-                    break;
-                case TSymbol:
-                    // do we have it in our symbol table? if yes, replace, else just push it in.
-                    char* sym = t->svalue();
-                    if (containsKey(symbols, sym)) {
-                        // does it look like *xxx ?? 
-                        if (sym[0] == '*') {
-                            // expand it.
-                            Token* star = symbols[sym];
-                            QuoteIterator *tx = (QuoteIterator*)star->qvalue()->tokens()->iterator();
-                            while(tx->hasNext()) {
-                                r->add(tx->next());
-                            }
-                        } else
-                            r->add(symbols[sym]);
+                    {
+                        P<QuoteStream> nq = (QuoteStream*)evalres(t->qvalue()->tokens(), symbols);
+                        P<Quote> q = new CmdQuote(nq);
+                        P<Token> t = new Term(TQuote, q);
+                        r->add(t);
                         break;
                     }
+                case TSymbol:
+                    {
+                        // do we have it in our symbol table? if yes, replace, else just push it in.
+                        P<char> sym = t->svalue();
+                        if (containsKey(symbols, sym)) {
+                            // does it look like *xxx ?? 
+                            if (sym[0] == '*') {
+                                // expand it.
+                                P<Token> star = symbols[sym];
+                                P<QuoteIterator> tx = (QuoteIterator*)star->qvalue()->tokens()->iterator();
+                                while(tx->hasNext()) {
+                                    r->add(tx->next());
+                                }
+                            } else
+                                r->add(symbols[sym]);
+                            break;
+                        }
+                    }
                 default:
                     // just push it in.
                     r->add(t);
@@ -199,7 +206,8 @@
 struct Ctrue : public Cmd {
     void eval(VFrame* q) {
         VStack* p = q->stack();
-        p->push(new Term(TBool, true));
+        P<Token> t = new Term(TBool, true);
+        p->push(t);
     }
     char* to_s() {return "true";}
 };
@@ -207,7 +215,8 @@
 struct Cfalse : public Cmd {
     void eval(VFrame* q) {
         VStack* p = q->stack();
-        p->push(new Term(TBool, false));
+        P<Token> t = new Term(TBool, false);
+        p->push(t);
     }
     char* to_s() {return "false";}
 };
Index: buffcharstream.cpp
===================================================================
--- buffcharstream.cpp	(revision 230)
+++ buffcharstream.cpp	(working copy)
@@ -15,7 +15,7 @@
 bool BuffCharStream::eof() {
     return (_current+1) >= _len;
 }
-BuffCharStream::BuffCharStream(char* buff):_current(-1) {
+BuffCharStream::BuffCharStream(char* buff):_current(-1), _buf(0) {
     if (buff) {
         _len = strlen(buff);
         _buf = dup_str(buff);
Index: common.h
===================================================================
--- common.h	(revision 230)
+++ common.h	(working copy)
@@ -12,4 +12,6 @@
 static const double Precision = 0.0000000000000001;
 static const int MaxBuf = 1024;
 
+#include "gc.h"
+
 #endif
