Index: charstream.h
===================================================================
--- charstream.h	(revision 252)
+++ charstream.h	(working copy)
@@ -2,7 +2,7 @@
 #define CHARSTREAM_H
 #include "common.h"
 struct Lexer;
-struct CharStream {
+struct CharStream : public virtual Obj {
    virtual char read()=0;
    virtual char current()=0;
    virtual char peek()=0;
Index: vstack.h
===================================================================
--- vstack.h	(revision 252)
+++ vstack.h	(working copy)
@@ -2,7 +2,7 @@
 #define VSTACK_H
 #include "term.h"
 struct Quote;
-class VStack {
+class VStack : public virtual Obj {
     public:
         VStack();
         Node* now();
Index: tokenstream.h
===================================================================
--- tokenstream.h	(revision 252)
+++ tokenstream.h	(working copy)
@@ -2,7 +2,7 @@
 #define TOKENSTREAM_H
 #include "common.h"
 class TokenIterator;
-struct TokenStream {
+struct TokenStream : public virtual Obj {
     virtual TokenIterator* iterator()=0;
 };
 
Index: vx.h
===================================================================
--- vx.h	(revision 252)
+++ vx.h	(working copy)
@@ -1,6 +1,6 @@
 #ifndef VX_H
 #define VX_H
-struct Vx {
+struct Vx : public virtual Obj {
     virtual char* message() = 0;
     virtual void addLine(char* v, ...) = 0;
 };
Index: allocator.cpp
===================================================================
--- allocator.cpp	(revision 252)
+++ allocator.cpp	(working copy)
@@ -1,28 +1,63 @@
-#include <vector>
+#include <list>
 #include <iostream>
+#include <iomanip>
 #include <stdlib.h>
 #include "allocator.h"
 using namespace std;
 
-typedef std::vector<void*> Mobj;
+typedef std::list<void*> Mobj;
 Mobj __objects;
+Mobj __prim;
 
+int L_SIZE = sizeof(long);
+
+void* operator new(size_t t, Collect) {
+    void *p = malloc(t + L_SIZE);
+    if (!p)
+        throw "Not enough mem";
+    long* i = (long*)p;
+    *i = 0;
+    __prim.push_back(p);
+    cout <<setbase(16) << (long)p + L_SIZE << endl;
+    return (char*)p+L_SIZE;
+}
+
+void* operator new[](size_t t, Collect) {
+    void *p = malloc(t + L_SIZE);
+    if (!p)
+        throw "Not enough mem";
+    long* i = (long*)p;
+    *i = 0;
+    __prim.push_back(p);
+    cout <<setbase(16) << (long)p + L_SIZE << endl;
+    return (char*)p+L_SIZE;
+}
+
 // leave the space in each object for reference counting.
-void * operator new (size_t t, Collect) {
-    void *p = malloc(t + sizeof(long));
+void* Obj::operator new(size_t t, Collect) {
+    void *p = malloc(t + L_SIZE);
+    if (!p)
+        throw "Not enough mem";
     long* i = (long*)p;
     *i = 0;
     __objects.push_back(p);
-    return (char*)p+sizeof(long);
+    return (char*)p+L_SIZE;
 }
-void * operator new[] (size_t t, Collect) {
-    void *p = malloc(t + sizeof(long));
+
+void* Obj::operator new[](size_t t, Collect) {
+    void *p = malloc(t + L_SIZE);
+    if (!p)
+        throw "Not enough mem";
     long* i = (long*)p;
     *i = 0;
     __objects.push_back(p);
-    return (char*)p+sizeof(long);
+    return (char*)p+L_SIZE;
 }
 
+Obj::~Obj() {
+    //cout<<"Obj Destroy called ++++++++++" <<endl;
+}
+
 void show() {
     int zeros = 0;
     int more = 0;
@@ -34,9 +69,41 @@
                 zeros++;
                 break;
             default:
+                if (*p < 0)
+                    throw "Bad num.";
                 more++;
                 total += *p;
         }
     }
     cout<<"unref :"<< zeros <<" ref :"<< more << " totalref :"<< total <<endl;
 }
+
+// problems:
+// Distructors of objects are not called which means members are not destroyed,
+// which is needed for us to get their references down.
+//
+// Dont know how to handle objects in stack.
+
+void gc() {
+    int j = 0;
+    for (Mobj::iterator i = __objects.begin(); i != __objects.end(); i++) {
+        void* v = *i;
+        long* p = (long*) v;
+        //cout << (long)p << endl;
+        if (!*p) {
+            Obj* o = (Obj*) ((char*)v + L_SIZE);
+            if (o) {
+                o->~Obj();
+                free(v);
+                *i = 0;
+                ++j;
+            } else {
+                cout << "Danter ================"<<endl;
+            }
+        }
+    }
+    cout << "Deleted: " << j << endl;
+    cout << "Size1: " << __objects.size() << endl;
+    __objects.remove(0);
+    cout << "Size2: " << __objects.size() << endl;
+}
Index: vframe.cpp
===================================================================
--- vframe.cpp	(revision 252)
+++ vframe.cpp	(working copy)
@@ -5,6 +5,9 @@
 #include "quotestream.h"
 #include "term.h"
 #include "cmdquote.h"
+#include <iostream>
+#include <iomanip>
+using namespace std;
 
 bool singleassign(); // defined in v.cpp
 int VFrame::_idcount = 0;
@@ -15,6 +18,10 @@
 VFrame::VFrame(VFrame* parent):_parent(parent),_stack(parent->stack()),_id(0) {
     _idcount++;
     _id = _idcount;
+    if (parent == this) {
+        cout<< "XX:"  << setbase(16) << (long) parent<<endl;
+        throw "bad parent";
+    }
 }
 int VFrame::id() {
     return _id;
@@ -40,7 +47,7 @@
     return new (collect) CmdQuote(nts); 
 }
 void VFrame::def(char* sym, Quote* q) {
-    char* s = Sym::lookup(sym);
+    P<char> s = Sym::lookup(sym);
     if (singleassign() && hasKey(s))
         throw VException("err:symbol_already_bound", new (collect) Term(TSymbol, s), s);
     _dict[s] = q;
Index: cmdquote.cpp
===================================================================
--- cmdquote.cpp	(revision 252)
+++ cmdquote.cpp	(working copy)
@@ -33,6 +33,7 @@
     if (!q)
         throw VException("err:undef_symbol", sym, sym->value());
     try {
+        gc();
         q->eval(scope->child());
     } catch (VException& e) {
         e.addLine(sym->value());
Index: common.cpp
===================================================================
--- common.cpp	(revision 252)
+++ common.cpp	(working copy)
@@ -1,9 +1,20 @@
 #include "common.h"
 #include <string.h>
 
-char* dup_str(const char* c) {
+char* dup_str(const char* c,bool b) {
     int i = strlen(c);
-    P<char,true> out = new (collect) char[i + 1];
-    strcpy(out, c);
-    return out;
+    if (b) {
+        P<char,true> out = new (collect) char[i + 1];
+        strcpy(out, c);
+        return out;
+    } else {
+        char* out = new (collect) char[i + 1];
+        strcpy(out, c);
+        return out;
+    }
 }
+
+void* __bottom_ptr = new char[0];
+bool invalid(void* p) {
+    return p <= __bottom_ptr;
+}
Index: vstack.cpp
===================================================================
--- vstack.cpp	(revision 252)
+++ vstack.cpp	(working copy)
@@ -25,7 +25,7 @@
 Token* VStack::pop() {
     if (!_now || !_now->data)
         throw VException("err:stack_empty", new (collect) Term(TInt, (long)0), "Empty Stack.");
-    Token* t = _now->data;
+    P<Token> t = _now->data;
     _now = _now->link;
     return t;
 }
@@ -77,7 +77,7 @@
 }
 
 void VStack::dump() {
-    Node* s = getList();
+    P<Node> s = getList();
     printf("(");
     bool first = true;
     while(s) {
Index: tokeniterator.h
===================================================================
--- tokeniterator.h	(revision 252)
+++ tokeniterator.h	(working copy)
@@ -1,7 +1,8 @@
 #ifndef TOKENITERATOR_H
 #define TOKENITERATOR_H
+#include "common.h"
 class Token;
-struct TokenIterator {
+struct TokenIterator : public virtual Obj {
     virtual bool hasNext()=0;
     virtual Token* next()=0;
 };
Index: quote.h
===================================================================
--- quote.h	(revision 252)
+++ quote.h	(working copy)
@@ -3,7 +3,7 @@
 #include "common.h"
 class TokenStream;
 class VFrame;
-struct Quote {
+struct Quote : public virtual Obj {
     virtual void eval(VFrame* scope) = 0;
     virtual TokenStream* tokens() = 0;
     virtual char* to_s() = 0;
Index: v.cpp
===================================================================
--- v.cpp	(revision 252)
+++ v.cpp	(working copy)
@@ -95,5 +95,15 @@
         printf("clock: %ld\n", clock());
     }
     show();
+    gc();
+    show();
+    gc();
+    show();
+    gc();
+    show();
+    gc();
+    show();
+    gc();
+    show();
     return 0;
 }
Index: term.cpp
===================================================================
--- term.cpp	(revision 252)
+++ term.cpp	(working copy)
@@ -15,7 +15,7 @@
 
 Term::Term(Type t,char* val):_type(t),_hold(0) {
     _sval = val;
-    _hold = _sval;
+    _hold = val;
 }
 
 Term::Term(Type t,long val):_num(val),_type(t),_hold(0) {
@@ -28,12 +28,12 @@
 
 Term::Term(Type t,Quote* val):_type(t),_hold(0) {
     _qval = val;
-    _hold = _qval;
+    _hold = val;
 }
 
 Term::Term(Type t,VFrame* val):_type(t),_hold(0) {
     _fval = val;
-    _hold = _fval;
+    _hold = val;
 }
 
 int Term::size() {
Index: sym.cpp
===================================================================
--- sym.cpp	(revision 252)
+++ sym.cpp	(working copy)
@@ -7,7 +7,7 @@
     bool operator()(char const *a, char const* b) {return strcmp(a,b) < 0; }
 };
 
-typedef std::map<char*, char*, cmp_str> SymbolTable;
+typedef std::map<char*, P<char>, cmp_str> SymbolTable;
 
 SymbolTable __symbols;
 
Index: ptr.h
===================================================================
--- ptr.h	(revision 252)
+++ ptr.h	(working copy)
@@ -1,16 +1,17 @@
 #ifndef PTR_H
 #define PTR_H
+bool invalid(void*);
 struct Ptr {
     long* getp(void* p) {
         return (long*)((char*)p - sizeof(long));
     }
     void attach(void* p) {
-        if (!p) return;
+        if (invalid(p)) return;
         long* i = getp(p);
         (*i)++;
     }
     void detach(void* p) {
-        if (!p) return;
+        if (invalid(p)) return;
         long* i = getp(p);
         (*i)--;
     }
@@ -24,7 +25,7 @@
         }
 
         P(const P<T,A> &p) :val(p.val){
-            //attach(p.val);
+            attach(p.val);
         }
 
         /* return raw pointer */
Index: lexer.h
===================================================================
--- lexer.h	(revision 252)
+++ lexer.h	(working copy)
@@ -4,7 +4,7 @@
 #include "token.h"
 class CharStream;
 class CNode;
-class Lexer {
+class Lexer : public virtual Obj {
     public:
         Lexer(CharStream* q);
         void lex();
Index: vframe.h
===================================================================
--- vframe.h	(revision 252)
+++ vframe.h	(working copy)
@@ -5,8 +5,8 @@
 class Quote;
 class VStack;
 // constant strings, does not need cmp_str.
-typedef std::map<char*, Quote*> QMap;
-class VFrame {
+typedef std::map<P<char>, P<Quote> > QMap;
+class VFrame : public virtual Obj {
     public:
         int id();
 
Index: token.h
===================================================================
--- token.h	(revision 252)
+++ token.h	(working copy)
@@ -6,7 +6,7 @@
 class Quote;
 class VFrame;
 class Num;
-struct Token {
+struct Token : public virtual Obj {
     virtual char* value()=0;
     virtual Type type()=0;
     virtual bool bvalue()=0;
Index: allocator.h
===================================================================
--- allocator.h	(revision 252)
+++ allocator.h	(working copy)
@@ -2,7 +2,15 @@
 #define ALLOCATOR_H
 #include <new>
 enum Collect {collect};
+void show();
+void gc();
+
 void * operator new (size_t t, Collect);
 void * operator new[] (size_t t, Collect);
-void show();
+struct Obj {
+    void * operator new (size_t t, Collect);
+    void * operator new[] (size_t t, Collect);
+    virtual ~Obj();
+};
+
 #endif
Index: prologue.cpp
===================================================================
--- prologue.cpp	(revision 252)
+++ prologue.cpp	(working copy)
@@ -1474,6 +1474,6 @@
     // math
     frame->def("sqrt", new (collect) Csqrt);
 
-    Quote* libs = CmdQuote::getdef("'std' use");
+    P<Quote> libs = CmdQuote::getdef("'std' use");
     libs->eval(frame);
 }
Index: common.h
===================================================================
--- common.h	(revision 252)
+++ common.h	(working copy)
@@ -4,7 +4,7 @@
 static const double Precision = 0.0000000000000001;
 static const int MaxBuf = 1024;
 
-char* dup_str(const char* c);
+char* dup_str(const char* c, bool b=true);
 
 #include "allocator.h"
 #include "ptr.h"
